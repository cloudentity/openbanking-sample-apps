// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OBWriteFundsConfirmationResponse1 o b write funds confirmation response1
//
// swagger:model OBWriteFundsConfirmationResponse1
type OBWriteFundsConfirmationResponse1 struct {

	// data
	// Required: true
	Data *OBWriteFundsConfirmationResponse1Data `json:"Data"`

	// links
	Links *Links `json:"Links,omitempty"`

	// meta
	Meta *Meta `json:"Meta,omitempty"`
}

// Validate validates this o b write funds confirmation response1
func (m *OBWriteFundsConfirmationResponse1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteFundsConfirmationResponse1) validateData(formats strfmt.Registry) error {

	if err := validate.Required("Data", "body", m.Data); err != nil {
		return err
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteFundsConfirmationResponse1) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Links")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteFundsConfirmationResponse1) validateMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.Meta) { // not required
		return nil
	}

	if m.Meta != nil {
		if err := m.Meta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Meta")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write funds confirmation response1 based on the context it is used
func (m *OBWriteFundsConfirmationResponse1) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteFundsConfirmationResponse1) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {
		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteFundsConfirmationResponse1) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Links")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteFundsConfirmationResponse1) contextValidateMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.Meta != nil {
		if err := m.Meta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Meta")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1) UnmarshalBinary(b []byte) error {
	var res OBWriteFundsConfirmationResponse1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteFundsConfirmationResponse1Data o b write funds confirmation response1 data
//
// swagger:model OBWriteFundsConfirmationResponse1Data
type OBWriteFundsConfirmationResponse1Data struct {

	// funds available result
	FundsAvailableResult *OBWriteFundsConfirmationResponse1DataFundsAvailableResult `json:"FundsAvailableResult,omitempty"`

	// supplementary data
	SupplementaryData OBSupplementaryData1 `json:"SupplementaryData,omitempty"`
}

// Validate validates this o b write funds confirmation response1 data
func (m *OBWriteFundsConfirmationResponse1Data) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFundsAvailableResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteFundsConfirmationResponse1Data) validateFundsAvailableResult(formats strfmt.Registry) error {
	if swag.IsZero(m.FundsAvailableResult) { // not required
		return nil
	}

	if m.FundsAvailableResult != nil {
		if err := m.FundsAvailableResult.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "FundsAvailableResult")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write funds confirmation response1 data based on the context it is used
func (m *OBWriteFundsConfirmationResponse1Data) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFundsAvailableResult(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteFundsConfirmationResponse1Data) contextValidateFundsAvailableResult(ctx context.Context, formats strfmt.Registry) error {

	if m.FundsAvailableResult != nil {
		if err := m.FundsAvailableResult.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "FundsAvailableResult")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1Data) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1Data) UnmarshalBinary(b []byte) error {
	var res OBWriteFundsConfirmationResponse1Data
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteFundsConfirmationResponse1DataFundsAvailableResult Result of a funds availability check.
//
// swagger:model OBWriteFundsConfirmationResponse1DataFundsAvailableResult
type OBWriteFundsConfirmationResponse1DataFundsAvailableResult struct {

	// Flag to indicate the availability of funds given the Amount in the consent request.
	// Required: true
	FundsAvailable *bool `json:"FundsAvailable"`

	// Date and time at which the funds availability check was generated.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	FundsAvailableDateTime *strfmt.DateTime `json:"FundsAvailableDateTime"`
}

// Validate validates this o b write funds confirmation response1 data funds available result
func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFundsAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFundsAvailableDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) validateFundsAvailable(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"FundsAvailableResult"+"."+"FundsAvailable", "body", m.FundsAvailable); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) validateFundsAvailableDateTime(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"FundsAvailableResult"+"."+"FundsAvailableDateTime", "body", m.FundsAvailableDateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("Data"+"."+"FundsAvailableResult"+"."+"FundsAvailableDateTime", "body", "date-time", m.FundsAvailableDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this o b write funds confirmation response1 data funds available result based on context it is used
func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteFundsConfirmationResponse1DataFundsAvailableResult) UnmarshalBinary(b []byte) error {
	var res OBWriteFundsConfirmationResponse1DataFundsAvailableResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
