// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OBWriteDomesticStandingOrder3 o b write domestic standing order3
//
// swagger:model OBWriteDomesticStandingOrder3
type OBWriteDomesticStandingOrder3 struct {

	// data
	// Required: true
	Data *OBWriteDomesticStandingOrder3Data `json:"Data"`

	// risk
	// Required: true
	Risk *OBRisk1 `json:"Risk"`
}

// Validate validates this o b write domestic standing order3
func (m *OBWriteDomesticStandingOrder3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRisk(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3) validateData(formats strfmt.Registry) error {

	if err := validate.Required("Data", "body", m.Data); err != nil {
		return err
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3) validateRisk(formats strfmt.Registry) error {

	if err := validate.Required("Risk", "body", m.Risk); err != nil {
		return err
	}

	if m.Risk != nil {
		if err := m.Risk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Risk")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 based on the context it is used
func (m *OBWriteDomesticStandingOrder3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRisk(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {
		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3) contextValidateRisk(ctx context.Context, formats strfmt.Registry) error {

	if m.Risk != nil {
		if err := m.Risk.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Risk")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3Data o b write domestic standing order3 data
//
// swagger:model OBWriteDomesticStandingOrder3Data
type OBWriteDomesticStandingOrder3Data struct {

	// OB: Unique identification as assigned by the ASPSP to uniquely identify the consent resource.
	// Required: true
	// Max Length: 128
	// Min Length: 1
	ConsentID *string `json:"ConsentId"`

	// initiation
	// Required: true
	Initiation *OBWriteDomesticStandingOrder3DataInitiation `json:"Initiation"`
}

// Validate validates this o b write domestic standing order3 data
func (m *OBWriteDomesticStandingOrder3Data) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConsentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitiation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3Data) validateConsentID(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"ConsentId", "body", m.ConsentID); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"ConsentId", "body", *m.ConsentID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"ConsentId", "body", *m.ConsentID, 128); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3Data) validateInitiation(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation", "body", m.Initiation); err != nil {
		return err
	}

	if m.Initiation != nil {
		if err := m.Initiation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data based on the context it is used
func (m *OBWriteDomesticStandingOrder3Data) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInitiation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3Data) contextValidateInitiation(ctx context.Context, formats strfmt.Registry) error {

	if m.Initiation != nil {
		if err := m.Initiation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3Data) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3Data) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3Data
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiation The Initiation payload is sent by the initiating party to the ASPSP. It is used to request movement of funds from the debtor account to a creditor for a domestic standing order.
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiation
type OBWriteDomesticStandingOrder3DataInitiation struct {

	// creditor account
	// Required: true
	CreditorAccount *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount `json:"CreditorAccount"`

	// debtor account
	DebtorAccount *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount `json:"DebtorAccount,omitempty"`

	// final payment amount
	FinalPaymentAmount *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount `json:"FinalPaymentAmount,omitempty"`

	// The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	FinalPaymentDateTime strfmt.DateTime `json:"FinalPaymentDateTime,omitempty"`

	// first payment amount
	// Required: true
	FirstPaymentAmount *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount `json:"FirstPaymentAmount"`

	// The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	FirstPaymentDateTime *strfmt.DateTime `json:"FirstPaymentDateTime"`

	// Individual Definitions:
	// EvryDay - Every day
	// EvryWorkgDay - Every working day
	// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
	// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
	// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
	// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).
	// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December.
	// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
	// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December.
	// Individual Patterns:
	// EvryDay (ScheduleCode)
	// EvryWorkgDay (ScheduleCode)
	// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
	// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
	// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
	// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
	// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
	// EvryDay
	// EvryWorkgDay
	// IntrvlWkDay:0[1-9]:0[1-7]
	// WkInMnthDay:0[1-5]:0[1-7]
	// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
	// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
	// Full Regular Expression:
	// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	// Required: true
	// Pattern: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	Frequency *string `json:"Frequency"`

	// Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.
	// Max Length: 35
	// Min Length: 1
	NumberOfPayments string `json:"NumberOfPayments,omitempty"`

	// recurring payment amount
	RecurringPaymentAmount *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount `json:"RecurringPaymentAmount,omitempty"`

	// The date on which the first recurring payment for a Standing Order schedule will be made.
	// Usage: This must be populated only if the first recurring date is different to the first payment date.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	RecurringPaymentDateTime strfmt.DateTime `json:"RecurringPaymentDateTime,omitempty"`

	// Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
	// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
	// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.
	// Max Length: 35
	// Min Length: 1
	Reference string `json:"Reference,omitempty"`

	// supplementary data
	SupplementaryData OBSupplementaryData1 `json:"SupplementaryData,omitempty"`
}

// Validate validates this o b write domestic standing order3 data initiation
func (m *OBWriteDomesticStandingOrder3DataInitiation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreditorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumberOfPayments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateCreditorAccount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount", "body", m.CreditorAccount); err != nil {
		return err
	}

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateDebtorAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtorAccount) { // not required
		return nil
	}

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateFinalPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentAmount) { // not required
		return nil
	}

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateFinalPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"FinalPaymentDateTime", "body", "date-time", m.FinalPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateFirstPaymentAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount", "body", m.FirstPaymentAmount); err != nil {
		return err
	}

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateFirstPaymentDateTime(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentDateTime", "body", m.FirstPaymentDateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"FirstPaymentDateTime", "body", "date-time", m.FirstPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateFrequency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"Frequency", "body", m.Frequency); err != nil {
		return err
	}

	if err := validate.Pattern("Data"+"."+"Initiation"+"."+"Frequency", "body", *m.Frequency, `^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$`); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateNumberOfPayments(formats strfmt.Registry) error {
	if swag.IsZero(m.NumberOfPayments) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"NumberOfPayments", "body", m.NumberOfPayments, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"NumberOfPayments", "body", m.NumberOfPayments, 35); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateRecurringPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentAmount) { // not required
		return nil
	}

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateRecurringPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"RecurringPaymentDateTime", "body", "date-time", m.RecurringPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) validateReference(formats strfmt.Registry) error {
	if swag.IsZero(m.Reference) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"Reference", "body", m.Reference, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"Reference", "body", m.Reference, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreditorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinalPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirstPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecurringPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) contextValidateCreditorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) contextValidateDebtorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) contextValidateFinalPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) contextValidateFirstPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiation) contextValidateRecurringPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiation) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiationCreditorAccount Identification assigned by an institution to identify an account. This identification is known by the account owner.
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiationCreditorAccount
type OBWriteDomesticStandingOrder3DataInitiationCreditorAccount struct {

	// identification
	// Required: true
	Identification *Identification0 `json:"Identification"`

	// The account name is the name or names of the account owner(s) represented at an account level.
	// Note, the account name is not the product name or the nickname of the account.
	// OB: ASPSPs may carry out name validation for Confirmation of Payee, but it is not mandatory.
	// Required: true
	// Max Length: 350
	// Min Length: 1
	Name *string `json:"Name"`

	// scheme name
	// Required: true
	SchemeName *OBExternalAccountIdentification4Code `json:"SchemeName"`

	// secondary identification
	SecondaryIdentification SecondaryIdentification `json:"SecondaryIdentification,omitempty"`
}

// Validate validates this o b write domestic standing order3 data initiation creditor account
func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) validateIdentification(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if m.Identification != nil {
		if err := m.Identification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) validateName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", *m.Name, 350); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) validateSchemeName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if m.SchemeName != nil {
		if err := m.SchemeName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := m.SecondaryIdentification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation creditor account based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemeName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) contextValidateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.Identification != nil {
		if err := m.Identification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) contextValidateSchemeName(ctx context.Context, formats strfmt.Registry) error {

	if m.SchemeName != nil {
		if err := m.SchemeName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) contextValidateSecondaryIdentification(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecondaryIdentification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationCreditorAccount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiationCreditorAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiationDebtorAccount Provides the details to identify the debtor account.
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiationDebtorAccount
type OBWriteDomesticStandingOrder3DataInitiationDebtorAccount struct {

	// identification
	// Required: true
	Identification *Identification0 `json:"Identification"`

	// The account name is the name or names of the account owner(s) represented at an account level, as displayed by the ASPSP's online channels.
	// Note, the account name is not the product name or the nickname of the account.
	// Max Length: 350
	// Min Length: 1
	Name string `json:"Name,omitempty"`

	// scheme name
	// Required: true
	SchemeName *OBExternalAccountIdentification4Code `json:"SchemeName"`

	// secondary identification
	SecondaryIdentification SecondaryIdentification `json:"SecondaryIdentification,omitempty"`
}

// Validate validates this o b write domestic standing order3 data initiation debtor account
func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) validateIdentification(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if m.Identification != nil {
		if err := m.Identification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Name", "body", m.Name, 350); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) validateSchemeName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if m.SchemeName != nil {
		if err := m.SchemeName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := m.SecondaryIdentification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation debtor account based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemeName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) contextValidateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.Identification != nil {
		if err := m.Identification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) contextValidateSchemeName(ctx context.Context, formats strfmt.Registry) error {

	if m.SchemeName != nil {
		if err := m.SchemeName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) contextValidateSecondaryIdentification(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecondaryIdentification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationDebtorAccount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiationDebtorAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount The amount of the final Standing Order
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount
type OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order3 data initiation final payment amount
func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation final payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiationFinalPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount The amount of the first Standing Order
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount
type OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order3 data initiation first payment amount
func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation first payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiationFirstPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount The amount of the recurring Standing Order
//
// swagger:model OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount
type OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order3 data initiation recurring payment amount
func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order3 data initiation recurring payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrder3DataInitiationRecurringPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
