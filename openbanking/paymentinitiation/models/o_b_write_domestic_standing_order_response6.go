// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OBWriteDomesticStandingOrderResponse6 o b write domestic standing order response6
//
// swagger:model OBWriteDomesticStandingOrderResponse6
type OBWriteDomesticStandingOrderResponse6 struct {

	// data
	// Required: true
	Data *OBWriteDomesticStandingOrderResponse6Data `json:"Data"`

	// links
	Links *Links `json:"Links,omitempty"`

	// meta
	Meta *Meta `json:"Meta,omitempty"`
}

// Validate validates this o b write domestic standing order response6
func (m *OBWriteDomesticStandingOrderResponse6) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) validateData(formats strfmt.Registry) error {

	if err := validate.Required("Data", "body", m.Data); err != nil {
		return err
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {
		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Links")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) validateMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.Meta) { // not required
		return nil
	}

	if m.Meta != nil {
		if err := m.Meta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Meta")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {
		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links != nil {
		if err := m.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Links")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6) contextValidateMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.Meta != nil {
		if err := m.Meta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Meta")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6Data o b write domestic standing order response6 data
//
// swagger:model OBWriteDomesticStandingOrderResponse6Data
type OBWriteDomesticStandingOrderResponse6Data struct {

	// charges
	Charges []*OBWriteDomesticStandingOrderResponse6DataChargesItems0 `json:"Charges"`

	// OB: Unique identification as assigned by the ASPSP to uniquely identify the consent resource.
	// Required: true
	// Max Length: 128
	// Min Length: 1
	ConsentID *string `json:"ConsentId"`

	// Date and time at which the resource was created.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	CreationDateTime *strfmt.DateTime `json:"CreationDateTime"`

	// debtor
	Debtor *OBDebtorIdentification1 `json:"Debtor,omitempty"`

	// OB: Unique identification as assigned by the ASPSP to uniquely identify the domestic standing order resource.
	// Required: true
	// Max Length: 40
	// Min Length: 1
	DomesticStandingOrderID *string `json:"DomesticStandingOrderId"`

	// initiation
	// Required: true
	Initiation *OBWriteDomesticStandingOrderResponse6DataInitiation `json:"Initiation"`

	// multi authorisation
	MultiAuthorisation *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation `json:"MultiAuthorisation,omitempty"`

	// refund
	Refund *OBWriteDomesticStandingOrderResponse6DataRefund `json:"Refund,omitempty"`

	// Specifies the status of the payment order resource.
	// Required: true
	// Enum: [Cancelled InitiationCompleted InitiationFailed InitiationPending]
	Status *string `json:"Status"`

	// Date and time at which the resource status was updated.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	StatusUpdateDateTime *strfmt.DateTime `json:"StatusUpdateDateTime"`
}

// Validate validates this o b write domestic standing order response6 data
func (m *OBWriteDomesticStandingOrderResponse6Data) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDomesticStandingOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitiation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMultiAuthorisation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefund(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusUpdateDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateCharges(formats strfmt.Registry) error {
	if swag.IsZero(m.Charges) { // not required
		return nil
	}

	for i := 0; i < len(m.Charges); i++ {
		if swag.IsZero(m.Charges[i]) { // not required
			continue
		}

		if m.Charges[i] != nil {
			if err := m.Charges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Data" + "." + "Charges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateConsentID(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"ConsentId", "body", m.ConsentID); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"ConsentId", "body", *m.ConsentID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"ConsentId", "body", *m.ConsentID, 128); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateCreationDateTime(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"CreationDateTime", "body", m.CreationDateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("Data"+"."+"CreationDateTime", "body", "date-time", m.CreationDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateDebtor(formats strfmt.Registry) error {
	if swag.IsZero(m.Debtor) { // not required
		return nil
	}

	if m.Debtor != nil {
		if err := m.Debtor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Debtor")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateDomesticStandingOrderID(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"DomesticStandingOrderId", "body", m.DomesticStandingOrderID); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"DomesticStandingOrderId", "body", *m.DomesticStandingOrderID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"DomesticStandingOrderId", "body", *m.DomesticStandingOrderID, 40); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateInitiation(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation", "body", m.Initiation); err != nil {
		return err
	}

	if m.Initiation != nil {
		if err := m.Initiation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateMultiAuthorisation(formats strfmt.Registry) error {
	if swag.IsZero(m.MultiAuthorisation) { // not required
		return nil
	}

	if m.MultiAuthorisation != nil {
		if err := m.MultiAuthorisation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "MultiAuthorisation")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateRefund(formats strfmt.Registry) error {
	if swag.IsZero(m.Refund) { // not required
		return nil
	}

	if m.Refund != nil {
		if err := m.Refund.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund")
			}
			return err
		}
	}

	return nil
}

var oBWriteDomesticStandingOrderResponse6DataTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Cancelled","InitiationCompleted","InitiationFailed","InitiationPending"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		oBWriteDomesticStandingOrderResponse6DataTypeStatusPropEnum = append(oBWriteDomesticStandingOrderResponse6DataTypeStatusPropEnum, v)
	}
}

const (

	// OBWriteDomesticStandingOrderResponse6DataStatusCancelled captures enum value "Cancelled"
	OBWriteDomesticStandingOrderResponse6DataStatusCancelled string = "Cancelled"

	// OBWriteDomesticStandingOrderResponse6DataStatusInitiationCompleted captures enum value "InitiationCompleted"
	OBWriteDomesticStandingOrderResponse6DataStatusInitiationCompleted string = "InitiationCompleted"

	// OBWriteDomesticStandingOrderResponse6DataStatusInitiationFailed captures enum value "InitiationFailed"
	OBWriteDomesticStandingOrderResponse6DataStatusInitiationFailed string = "InitiationFailed"

	// OBWriteDomesticStandingOrderResponse6DataStatusInitiationPending captures enum value "InitiationPending"
	OBWriteDomesticStandingOrderResponse6DataStatusInitiationPending string = "InitiationPending"
)

// prop value enum
func (m *OBWriteDomesticStandingOrderResponse6Data) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, oBWriteDomesticStandingOrderResponse6DataTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("Data"+"."+"Status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) validateStatusUpdateDateTime(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"StatusUpdateDateTime", "body", m.StatusUpdateDateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("Data"+"."+"StatusUpdateDateTime", "body", "date-time", m.StatusUpdateDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6Data) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCharges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitiation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMultiAuthorisation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRefund(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) contextValidateCharges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Charges); i++ {

		if m.Charges[i] != nil {
			if err := m.Charges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("Data" + "." + "Charges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) contextValidateDebtor(ctx context.Context, formats strfmt.Registry) error {

	if m.Debtor != nil {
		if err := m.Debtor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Debtor")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) contextValidateInitiation(ctx context.Context, formats strfmt.Registry) error {

	if m.Initiation != nil {
		if err := m.Initiation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) contextValidateMultiAuthorisation(ctx context.Context, formats strfmt.Registry) error {

	if m.MultiAuthorisation != nil {
		if err := m.MultiAuthorisation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "MultiAuthorisation")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6Data) contextValidateRefund(ctx context.Context, formats strfmt.Registry) error {

	if m.Refund != nil {
		if err := m.Refund.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6Data) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6Data) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6Data
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataChargesItems0 Set of elements used to provide details of a charge for the payment initiation.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataChargesItems0
type OBWriteDomesticStandingOrderResponse6DataChargesItems0 struct {

	// amount
	// Required: true
	Amount *OBActiveOrHistoricCurrencyAndAmount `json:"Amount"`

	// charge bearer
	// Required: true
	ChargeBearer *OBChargeBearerType1Code `json:"ChargeBearer"`

	// type
	// Required: true
	Type *OBExternalPaymentChargeType1Code `json:"Type"`
}

// Validate validates this o b write domestic standing order response6 data charges items0
func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChargeBearer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) validateChargeBearer(formats strfmt.Registry) error {

	if err := validate.Required("ChargeBearer", "body", m.ChargeBearer); err != nil {
		return err
	}

	if err := validate.Required("ChargeBearer", "body", m.ChargeBearer); err != nil {
		return err
	}

	if m.ChargeBearer != nil {
		if err := m.ChargeBearer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ChargeBearer")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) validateType(formats strfmt.Registry) error {

	if err := validate.Required("Type", "body", m.Type); err != nil {
		return err
	}

	if err := validate.Required("Type", "body", m.Type); err != nil {
		return err
	}

	if m.Type != nil {
		if err := m.Type.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data charges items0 based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChargeBearer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) contextValidateChargeBearer(ctx context.Context, formats strfmt.Registry) error {

	if m.ChargeBearer != nil {
		if err := m.ChargeBearer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ChargeBearer")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if m.Type != nil {
		if err := m.Type.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataChargesItems0) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataChargesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiation The Initiation payload is sent by the initiating party to the ASPSP. It is used to request movement of funds from the debtor account to a creditor for a domestic standing order.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiation
type OBWriteDomesticStandingOrderResponse6DataInitiation struct {

	// creditor account
	// Required: true
	CreditorAccount *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount `json:"CreditorAccount"`

	// debtor account
	DebtorAccount *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount `json:"DebtorAccount,omitempty"`

	// final payment amount
	FinalPaymentAmount *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount `json:"FinalPaymentAmount,omitempty"`

	// The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	FinalPaymentDateTime strfmt.DateTime `json:"FinalPaymentDateTime,omitempty"`

	// first payment amount
	// Required: true
	FirstPaymentAmount *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount `json:"FirstPaymentAmount"`

	// The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Required: true
	// Format: date-time
	FirstPaymentDateTime *strfmt.DateTime `json:"FirstPaymentDateTime"`

	// Individual Definitions:
	// EvryDay - Every day
	// EvryWorkgDay - Every working day
	// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
	// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
	// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
	// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).
	// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December.
	// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
	// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December.
	// Individual Patterns:
	// EvryDay (ScheduleCode)
	// EvryWorkgDay (ScheduleCode)
	// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
	// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
	// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
	// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
	// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
	// EvryDay
	// EvryWorkgDay
	// IntrvlWkDay:0[1-9]:0[1-7]
	// WkInMnthDay:0[1-5]:0[1-7]
	// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
	// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
	// Full Regular Expression:
	// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	// Required: true
	// Pattern: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
	Frequency *string `json:"Frequency"`

	// Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.
	// Max Length: 35
	// Min Length: 1
	NumberOfPayments string `json:"NumberOfPayments,omitempty"`

	// recurring payment amount
	RecurringPaymentAmount *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount `json:"RecurringPaymentAmount,omitempty"`

	// The date on which the first recurring payment for a Standing Order schedule will be made.
	// Usage: This must be populated only if the first recurring date is different to the first payment date.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	RecurringPaymentDateTime strfmt.DateTime `json:"RecurringPaymentDateTime,omitempty"`

	// Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
	// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
	// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.
	// Max Length: 35
	// Min Length: 1
	Reference string `json:"Reference,omitempty"`

	// supplementary data
	SupplementaryData OBSupplementaryData1 `json:"SupplementaryData,omitempty"`
}

// Validate validates this o b write domestic standing order response6 data initiation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreditorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDebtorAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFinalPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFirstPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumberOfPayments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurringPaymentDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateCreditorAccount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount", "body", m.CreditorAccount); err != nil {
		return err
	}

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateDebtorAccount(formats strfmt.Registry) error {
	if swag.IsZero(m.DebtorAccount) { // not required
		return nil
	}

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateFinalPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentAmount) { // not required
		return nil
	}

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateFinalPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.FinalPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"FinalPaymentDateTime", "body", "date-time", m.FinalPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateFirstPaymentAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount", "body", m.FirstPaymentAmount); err != nil {
		return err
	}

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateFirstPaymentDateTime(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentDateTime", "body", m.FirstPaymentDateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"FirstPaymentDateTime", "body", "date-time", m.FirstPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateFrequency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"Frequency", "body", m.Frequency); err != nil {
		return err
	}

	if err := validate.Pattern("Data"+"."+"Initiation"+"."+"Frequency", "body", *m.Frequency, `^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$`); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateNumberOfPayments(formats strfmt.Registry) error {
	if swag.IsZero(m.NumberOfPayments) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"NumberOfPayments", "body", m.NumberOfPayments, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"NumberOfPayments", "body", m.NumberOfPayments, 35); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateRecurringPaymentAmount(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentAmount) { // not required
		return nil
	}

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateRecurringPaymentDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.RecurringPaymentDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"Initiation"+"."+"RecurringPaymentDateTime", "body", "date-time", m.RecurringPaymentDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) validateReference(formats strfmt.Registry) error {
	if swag.IsZero(m.Reference) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"Reference", "body", m.Reference, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"Reference", "body", m.Reference, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCreditorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDebtorAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFinalPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFirstPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRecurringPaymentAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) contextValidateCreditorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.CreditorAccount != nil {
		if err := m.CreditorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) contextValidateDebtorAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.DebtorAccount != nil {
		if err := m.DebtorAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) contextValidateFinalPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FinalPaymentAmount != nil {
		if err := m.FinalPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) contextValidateFirstPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.FirstPaymentAmount != nil {
		if err := m.FirstPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) contextValidateRecurringPaymentAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.RecurringPaymentAmount != nil {
		if err := m.RecurringPaymentAmount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiation) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount Identification assigned by an institution to identify an account. This identification is known by the account owner.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount
type OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount struct {

	// identification
	// Required: true
	Identification *Identification0 `json:"Identification"`

	// The account name is the name or names of the account owner(s) represented at an account level.
	// Note, the account name is not the product name or the nickname of the account.
	// OB: ASPSPs may carry out name validation for Confirmation of Payee, but it is not mandatory.
	// Required: true
	// Max Length: 350
	// Min Length: 1
	Name *string `json:"Name"`

	// scheme name
	// Required: true
	SchemeName *OBExternalAccountIdentification4Code `json:"SchemeName"`

	// secondary identification
	SecondaryIdentification SecondaryIdentification `json:"SecondaryIdentification,omitempty"`
}

// Validate validates this o b write domestic standing order response6 data initiation creditor account
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) validateIdentification(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if m.Identification != nil {
		if err := m.Identification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) validateName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"Name", "body", *m.Name, 350); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) validateSchemeName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"CreditorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if m.SchemeName != nil {
		if err := m.SchemeName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := m.SecondaryIdentification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation creditor account based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemeName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) contextValidateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.Identification != nil {
		if err := m.Identification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) contextValidateSchemeName(ctx context.Context, formats strfmt.Registry) error {

	if m.SchemeName != nil {
		if err := m.SchemeName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) contextValidateSecondaryIdentification(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecondaryIdentification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "CreditorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiationCreditorAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount Provides the details to identify the debtor account.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount
type OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount struct {

	// identification
	// Required: true
	Identification *Identification0 `json:"Identification"`

	// The account name is the name or names of the account owner(s) represented at an account level, as displayed by the ASPSP's online channels.
	// Note, the account name is not the product name or the nickname of the account.
	// Max Length: 350
	// Min Length: 1
	Name string `json:"Name,omitempty"`

	// scheme name
	// Required: true
	SchemeName *OBExternalAccountIdentification4Code `json:"SchemeName"`

	// secondary identification
	SecondaryIdentification SecondaryIdentification `json:"SecondaryIdentification,omitempty"`
}

// Validate validates this o b write domestic standing order response6 data initiation debtor account
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) validateIdentification(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if m.Identification != nil {
		if err := m.Identification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.MinLength("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Name", "body", m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"Name", "body", m.Name, 350); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) validateSchemeName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"DebtorAccount"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if m.SchemeName != nil {
		if err := m.SchemeName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := m.SecondaryIdentification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation debtor account based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemeName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) contextValidateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.Identification != nil {
		if err := m.Identification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) contextValidateSchemeName(ctx context.Context, formats strfmt.Registry) error {

	if m.SchemeName != nil {
		if err := m.SchemeName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) contextValidateSecondaryIdentification(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecondaryIdentification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Initiation" + "." + "DebtorAccount" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiationDebtorAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount The amount of the final Standing Order
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount
type OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order response6 data initiation final payment amount
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FinalPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation final payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FinalPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiationFinalPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount The amount of the first Standing Order
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount
type OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order response6 data initiation first payment amount
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"FirstPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation first payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "FirstPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiationFirstPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount The amount of the recurring Standing Order
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount
type OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount struct {

	// amount
	// Required: true
	Amount *OBActiveCurrencyAndAmountSimpleType `json:"Amount"`

	// currency
	// Required: true
	Currency *ActiveOrHistoricCurrencyCode `json:"Currency"`
}

// Validate validates this o b write domestic standing order response6 data initiation recurring payment amount
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) validateAmount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Amount", "body", m.Amount); err != nil {
		return err
	}

	if m.Amount != nil {
		if err := m.Amount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Initiation"+"."+"RecurringPaymentAmount"+"."+"Currency", "body", m.Currency); err != nil {
		return err
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data initiation recurring payment amount based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAmount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCurrency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) contextValidateAmount(ctx context.Context, formats strfmt.Registry) error {

	if m.Amount != nil {
		if err := m.Amount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Amount")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) contextValidateCurrency(ctx context.Context, formats strfmt.Registry) error {

	if m.Currency != nil {
		if err := m.Currency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Initiation" + "." + "RecurringPaymentAmount" + "." + "Currency")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataInitiationRecurringPaymentAmount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation The multiple authorisation flow response from the ASPSP.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation
type OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation struct {

	// Date and time at which the requested authorisation flow must be completed.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	ExpirationDateTime strfmt.DateTime `json:"ExpirationDateTime,omitempty"`

	// Last date and time at the authorisation flow was updated.All dates in the JSON payloads are represented in ISO 8601 date-time format.
	// All date-time fields in responses must include the timezone. An example is below:
	// 2017-04-05T10:43:07+00:00
	// Format: date-time
	LastUpdateDateTime strfmt.DateTime `json:"LastUpdateDateTime,omitempty"`

	// Number of authorisations received.
	NumberReceived int64 `json:"NumberReceived,omitempty"`

	// Number of authorisations required for payment order (total required at the start of the multi authorisation journey).
	NumberRequired int64 `json:"NumberRequired,omitempty"`

	// Specifies the status of the authorisation flow in code form.
	// Required: true
	// Enum: [Authorised AwaitingFurtherAuthorisation Rejected]
	Status *string `json:"Status"`
}

// Validate validates this o b write domestic standing order response6 data multi authorisation
func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateExpirationDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdateDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) validateExpirationDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpirationDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"MultiAuthorisation"+"."+"ExpirationDateTime", "body", "date-time", m.ExpirationDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) validateLastUpdateDateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.LastUpdateDateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("Data"+"."+"MultiAuthorisation"+"."+"LastUpdateDateTime", "body", "date-time", m.LastUpdateDateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var oBWriteDomesticStandingOrderResponse6DataMultiAuthorisationTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Authorised","AwaitingFurtherAuthorisation","Rejected"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		oBWriteDomesticStandingOrderResponse6DataMultiAuthorisationTypeStatusPropEnum = append(oBWriteDomesticStandingOrderResponse6DataMultiAuthorisationTypeStatusPropEnum, v)
	}
}

const (

	// OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusAuthorised captures enum value "Authorised"
	OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusAuthorised string = "Authorised"

	// OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusAwaitingFurtherAuthorisation captures enum value "AwaitingFurtherAuthorisation"
	OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusAwaitingFurtherAuthorisation string = "AwaitingFurtherAuthorisation"

	// OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusRejected captures enum value "Rejected"
	OBWriteDomesticStandingOrderResponse6DataMultiAuthorisationStatusRejected string = "Rejected"
)

// prop value enum
func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, oBWriteDomesticStandingOrderResponse6DataMultiAuthorisationTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"MultiAuthorisation"+"."+"Status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("Data"+"."+"MultiAuthorisation"+"."+"Status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this o b write domestic standing order response6 data multi authorisation based on context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataMultiAuthorisation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataRefund Unambiguous identification of the refund account to which a refund will be made as a result of the transaction.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataRefund
type OBWriteDomesticStandingOrderResponse6DataRefund struct {

	// account
	// Required: true
	Account *OBWriteDomesticStandingOrderResponse6DataRefundAccount `json:"Account"`
}

// Validate validates this o b write domestic standing order response6 data refund
func (m *OBWriteDomesticStandingOrderResponse6DataRefund) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefund) validateAccount(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account", "body", m.Account); err != nil {
		return err
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data refund based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataRefund) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefund) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if m.Account != nil {
		if err := m.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataRefund) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataRefund) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataRefund
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// OBWriteDomesticStandingOrderResponse6DataRefundAccount Provides the details to identify an account.
//
// swagger:model OBWriteDomesticStandingOrderResponse6DataRefundAccount
type OBWriteDomesticStandingOrderResponse6DataRefundAccount struct {

	// identification
	// Required: true
	Identification *Identification0 `json:"Identification"`

	// Name of the account, as assigned by the account servicing institution.
	// Usage: The account name is the name or names of the account owner(s) represented at an account level. The account name is not the product name or the nickname of the account.
	// OB: ASPSPs may carry out name validation for Confirmation of Payee, but it is not mandatory.
	// Required: true
	// Max Length: 350
	// Min Length: 1
	Name *string `json:"Name"`

	// scheme name
	// Required: true
	SchemeName *OBExternalAccountIdentification4Code `json:"SchemeName"`

	// secondary identification
	SecondaryIdentification SecondaryIdentification `json:"SecondaryIdentification,omitempty"`
}

// Validate validates this o b write domestic standing order response6 data refund account
func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondaryIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) validateIdentification(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account"+"."+"Identification", "body", m.Identification); err != nil {
		return err
	}

	if m.Identification != nil {
		if err := m.Identification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) validateName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account"+"."+"Name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("Data"+"."+"Refund"+"."+"Account"+"."+"Name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("Data"+"."+"Refund"+"."+"Account"+"."+"Name", "body", *m.Name, 350); err != nil {
		return err
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) validateSchemeName(formats strfmt.Registry) error {

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if err := validate.Required("Data"+"."+"Refund"+"."+"Account"+"."+"SchemeName", "body", m.SchemeName); err != nil {
		return err
	}

	if m.SchemeName != nil {
		if err := m.SchemeName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) validateSecondaryIdentification(formats strfmt.Registry) error {
	if swag.IsZero(m.SecondaryIdentification) { // not required
		return nil
	}

	if err := m.SecondaryIdentification.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// ContextValidate validate this o b write domestic standing order response6 data refund account based on the context it is used
func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSchemeName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecondaryIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) contextValidateIdentification(ctx context.Context, formats strfmt.Registry) error {

	if m.Identification != nil {
		if err := m.Identification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "Identification")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) contextValidateSchemeName(ctx context.Context, formats strfmt.Registry) error {

	if m.SchemeName != nil {
		if err := m.SchemeName.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "SchemeName")
			}
			return err
		}
	}

	return nil
}

func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) contextValidateSecondaryIdentification(ctx context.Context, formats strfmt.Registry) error {

	if err := m.SecondaryIdentification.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("Data" + "." + "Refund" + "." + "Account" + "." + "SecondaryIdentification")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OBWriteDomesticStandingOrderResponse6DataRefundAccount) UnmarshalBinary(b []byte) error {
	var res OBWriteDomesticStandingOrderResponse6DataRefundAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
